    #
    # Calling conventions:
    #     %rdi, %rsi, %rdx, %rcx, %r8, %r9, %r10, %r11 and %rax are caller saved
    #     %rbx, %rbp, %r12, %r13, %r14 are callee saved
    #     %rsp can not be used except for its normal use as a stack pointer.
    #     argument are passed through registers %rdi, %rsi, %rdx in this order.
    #     values are returned through %rax
    
    .pos 0x100
    
    main:	irmovq bottom,  %rsp     # initialize stack
    	irmovq array, %rdi       # %rdi = pointer to first element of the array
    	xorq   %rax, %rax        # %rsi = size
    	mrmovq size(%rax), %rsi  # DH on rax
    	irmovq $1, %rax          # %rsi = size - 1
    	subq   %rax, %rsi        # DH on rax
    	irmovq $8, %r11
    	mulq   %r11, %rsi        # %rsi = 8 * (size - 1), can change the 3 addqs to mulq?
    	addq   %rdi, %rsi        # %rsi = pointer to last element of the array. DH on RSI
    	call   mergesort
		irmovq $1, %rax          #to check in simulator if it finished.
    	halt
    
    #
    # Mergesort
    #    %rdi: pointer to the first element of the range to sort.
    #    %rsi: pointer to the last element of the range to sort.
    #
    mergesort:
    	rrmovq %rsi, %rax  	    # is first < last ?
    	subq   %rdi, %rax       # DH on rax
    	jle    done             # if not, done.
    
    	rrmovq %rdi, %rdx
		irmovq $2,   %rax       # %rdx = mid. Note the use  of ANDQ.  WHOLE CHUNK DH
    	addq   %rsi, %rdx       # Since we're doing arithmetic  with   
    	       				# pointers, we can not rely only  on
    	divq   %rax, %rdx       # integer division to ensure  we get
    	irmovq $-8,  %rax       # a valid pointer.
    	andq   %rax, %rdx       
    							#think abt putting this in registers, then using those registers with mergesort
    	pushq  %rdi             #pushq 2x in row stalls on rsp
    	pushq  %rsi             
    	pushq  %rdx             
    	rrmovq %rdx, %rsi       # mergesort(first, mid)
    	call   mergesort
    	popq   %rdx             #pop then push right away, we can delete?
    	popq   %rsi             #pop also stalls
    	popq   %rdi
        
    	pushq  %rdi             # mergesort(mid+1, last)
    	pushq  %rsi             
    	pushq  %rdx 
    	rrmovq %rdx, %rdi       #think abt this
    	irmovq $8, %rax
    	addq   %rax, %rdi
    	call   mergesort
    	popq   %rdx
    	popq   %rsi
    	popq   %rdi
    
    	call   merge            # merge(first, mid, last) - possibly can inline merge right here
    
    done:	ret
    
    #
    # Merge
    #    %rdi: pointer to the first element of the range to merge.
    #    %rsi: pointer to the last element of the range to merge.
    #    %rdx: pointer to the middle element of the range to merge.
    #
    # %rdi is i
    # %rcx is j
    # %rdx is mid
    # %rsi is last
    # %rbp is dest
    
    merge:
    	pushq  %rbp
    	rrmovq %rdx, %rcx    #weaving rrmovqs inside pushes
    	pushq  %rbx 
    	irmovq $8,   %rax
    	pushq  %rdi          # rdi was popped by mergesort!
    	addq   %rax, %rcx    # DH without DF
    	irmovq temp, %rbp    #falldown to mergeloop 1
        
    mergeloop1:	
    	rrmovq %rdx, %rax          # while (i <= mid && j <= last)
    	subq   %rdi, %rax          # DH on rax
    	jl     ml2copy1
    	
    	rrmovq %rsi, %rax
    	subq   %rcx, %rax
    	jl     ml2copy1
    
    	mrmovq 0(%rdi), %rax       # %rax = A[i]
    	mrmovq 0(%rcx), %rbx   	   # %rbx = A[j]
    	subq   %rax, %rbx          # if A[i] <= A[j] - DH on rbx
    	jl     mergecopy2
    
    	rmmovq %rax, 0(%rbp)       # copy A[i] to temp
    	irmovq $8, %rax
    	addq   %rax, %rbp
    	addq   %rax, %rdi
    	jmp    mergeloop1
    
    mergecopy2:
    	mrmovq 0(%rcx), %rbx       # %rbx = A[j] again - DH on rbx if jump from mergeloop1
    	rmmovq %rbx, 0(%rbp)       # DH on rbx
    	irmovq $8, %rax
    	addq   %rax, %rbp         
    	addq   %rax, %rcx           
    	jmp    mergeloop1
    	
    copycontinue1:
    	mrmovq 0(%rdi), %rax     #dh on rax from jump
    	rmmovq %rax, 0(%rbp)
    
    	irmovq $8, %rax  
    	addq   %rax, %rbp
    	addq   %rax, %rdi
    ml2copy1:	
    	rrmovq %rdx, %rax        #rdx used to be rsi, bc rdx had been movoed into rsi
    	subq   %rdi, %rax        #dh on rax
    	jge     copycontinue1
    	jmp copy2
    	
    copycontinue2:
    	mrmovq 0(%rcx), %rax     #dh on rax from jump
    	rmmovq %rax, 0(%rbp)
    
    	irmovq $8, %rax  
    	addq   %rax, %rbp
    	addq   %rax, %rcx
    	
    copy2:	
    	rrmovq %rsi, %rax
    	subq   %rcx, %rax        #dh on rax
    	jge     copycontinue2
    	
    cont2:
    	
    	popq   %rdi	              # Copy temp back to A[first] ... A[last]
    	subq   %rdi, %rsi  #rsi
    	rrmovq %rdi, %rdx
    	irmovq temp, %rdi             # instead of putting temp in rdi, put in somewhere else
    	addq   %rdi, %rsi
    	
    copy3:	
    	rrmovq %rsi, %rax
    	subq   %rdi, %rax        #dh on rax
    	jge     copycontinue3
    	rrmovq %rdx, %rax
    	jmp cont3
    	
    copycontinue3:
    	mrmovq 0(%rdi), %rax     #dh on rax from jump
    	rmmovq %rax, 0(%rdx)
    
    	irmovq $8, %rax  
    	addq   %rax, %rdx
    	addq   %rax, %rdi
    	jmp    copy3
    	
    cont3:	
    
    	popq   %rbx
    	popq   %rbp
    	ret
    
    # Copy helper.
    #    %rdi [input]: pointer to the first element to copy.
    #    %rsi [input]: pointer to the last element to copy.
    #    %rdx [input & output]: pointer to where the elements go.
    #	
    
    
    #
    # Array to sort
    #
    .pos 0x1000
    array:
    		.quad	0x2bc2a
    	.quad	0x43516
    	.quad	0xaf85c
    	.quad	0xe74e3
    	.quad	0x19e7a
    	.quad	0xfc255
    	.quad	0x37bcb
    	.quad	0x875fa
    	.quad	0xd60bb
    	.quad	0x58fcc
    	.quad	0x62e4d
    	.quad	0x82d8a
    	.quad	0x15e49
    
    #
    # Temporary array.
    #
    temp:   .quad 0,13
    
    
    #	
    # Array size.
    #	
    size:   .quad 13
    	
    #
    # Stack (32 sixty-four bit words is more than enough here).
    #
    .pos 0x3000
    top:	            .quad 0x00000000,0x20     # top of stack.
    bottom:             .quad 0x00000000          # bottom of stack.
    
